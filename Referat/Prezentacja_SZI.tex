\documentclass[a4paper,10pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[OT4,T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{ dsfont }
\usepackage{ amssymb }
\usepackage{enumerate}
\usepackage{tikz}

\usetheme{Warsaw}
\usecolortheme{beaver}

\newtheorem{defi}{Definicja}[subsection]
\newtheorem{uw}{Uwaga}[subsection]
\newtheorem{cel}{Cel}[subsection]
\newtheorem{tw}{Twierdzenie}[subsection]
\newtheorem{lem}{Lemat}[subsection]
\newtheorem{przyk}{Przykład}[subsection]
\newtheorem{alg}{Algorytm}[subsection]

\date{15 czerwca 2015}
\title{Inteligentny kelner}
\author[A. Bohonos, D. Demski, A. Limiszewska, A. Mieldzioc]{Andrzej Bohonos, Dominik Demski, Agnieszka Limiszewska, Adam Mieldzioc}

\begin{document}
		\begin{frame}
			\titlepage
		\end{frame}
		\begin{frame}{Agenda}
			\tableofcontents
		\end{frame}
		
		\section{Algorytmy genetyczne}
		\begin{frame}{Do czego zastosowałem algorytmy genetyczne?}
			Skorzystałem z biblioteki JGAP.
			\begin{defi}
				Komiwojażer musi odwiedzić wszystkie miasta z zadanego regionu i wrócić do miasta początkowego (jest to problem szukania cyklu). Wszystkie miasta są ze sobą połączone (mamy do czynienia z grafem pełnym). Mając do dyspozycji macierz odległości pomiędzy poszczególnymi miastami, należy znaleść cykl o najmniejszym koszcie, przy czym każde miasto nie może być odwiedzone więcej niż jeden raz.
			\end{defi}
			
		\end{frame}
		\begin{frame}{Problem komiwojażera w aplikacji}
			\begin{enumerate}
				\item miasta = stoły
				\item komiwojażer = kelner
			\end{enumerate}
		\end{frame}
		\begin{frame}{Kolejne elementy algorytmu genetycznego}
			\begin{alg}
				\begin{enumerate}
					\item Populacja
					\item Krzyżowanie
					\item Mutacja
					\item Ocena osobników
					\item Selekcja
				\end{enumerate}
			\end{alg}
		\end{frame}
		\begin{frame}{Populacja}
			\begin{enumerate}
				\item Rozmiar populacji: 1000
				\item Ilość ewolucji: 2000
				\item Na początku osobniki tworzone są w sposób losowy - na podstawie przykładowego chromosomu.
			\end{enumerate}
		\end{frame}
		\begin{frame}{Reprezentacja chromosomu}
			Pojedynczy chromosom ma reprezentować proponowaną kolejność odwiedzania stolików. Chromosom reprezentuję jako listę pokazująca kolejność pobierania stolików do tworzonej trasy.
			
			\begin{przyk}
					Punktem odniesienia dla tej reprezentacji jest lista kolejnych stolików: 1-2-3-4-5. Pojedynczy osobnik np. 3-3-0-1-0 pokazuje w jakiej kolejności wybierane są kolejno odwiedzane stoliki. Na początku jest trójka więc pierwszym odwiedzanym stolikiem będzie stolik umieszczony na trzeciej pozycji w liście odniesienia, czyli czwórka. Czwórkę tę usuwa się z listy odniesienia (pozostają stoliki 1-2-3-5), natomiast lista odwiedzanych stolików wygląda następująco: 4.
					Kolejnym elementem osobnika jest ponownie trójka. W tej chwili na trzecim miejscu listy odniesienia jest piątka, więc kolejnym odwiedzanym stolikiem będzie stolik nr 5, a lista odniesienia będzie wyglądała następująco: 1-2-3 itd.
			\end{przyk}
		\end{frame}
		\begin{frame}{Wady i zalety takiej reprezentacji}
			Reprezentacja ta wprowadza spore zamieszanie przy przechodzeniu na reprezentację wykorzystywaną przy funcji oceny, jednak kłopoty te rekompensuje przy krzyżowaniu i mutacji. Cechą charakterystyczą tej reprezentacji jest fakt, że na i-tej pozycji jest liczba z przedziału od 0 do n-i-1 (gzie n to liczba wszystkich stolików, np. na miejscu zerowym wszystkie miejsca są jeszcze do wybrania, jest więc n - 0 możliwości, należy odjąć 1, bo lista numerowana jest od zera). Ze względu na to wymiana materiału genetycznego między dwoma osobnikami za pomocą standardowego krzyżowania x-punktowego zawsze da dopuszczalne potomstwo.
		\end{frame}
		\begin{frame}{Kod}
			\pgfdeclareimage[width=10cm,height=8cm]{chromosom}{przykladowyChromosom.png}
			\pgfuseimage{chromosom}
		\end{frame}
		\begin{frame}{Kod}
			\pgfdeclareimage[width=9cm,height=6cm]{chromosom}{zamianaNaChromosom.png}
			\pgfuseimage{chromosom}
		\end{frame}
	
		\begin{frame}{Krzyżowanie}
			35 procent populacji bierze udział w krzyżowaniu - każde krzyżowanie daje dwa nowe osobniki. Zastosowałem krzyżowanie jednopunktowe, punkt krzyżowania wybierany jest w sposób losowy. 
		\end{frame}
		\begin{frame}{Mutacja}
			Mutacja występuje, jesli wylosowana z przedziału [0, 12] liczba całkowita jest zerem, co daje prawdopodobieństwo mutacji 1/12. Taka operacja jest stosowana do każdego genu w każdym chromosomie - z wyjątkiem tych, które dopiero co powstały w wyniku krzyżowania.
		\end{frame}
			\begin{frame}{Ocena osobników - jak mierzę odległość między stolikami?}
				Wykorzystuję odległość miejską - bo tak mniej więcej będzie chodził kelner:
				\begin{defi}
					Odległość miejska (zwana również odległością taksówkową lub manhatańską):  
					\begin{equation}
					\rho (\textbf{x}_{r}, \textbf{x}_s) = \sum\limits_{i = 1}^{p} |(x_{ri} - x_{si})|
					\end{equation}
				\end{defi}
			\end{frame}
			\begin{frame}
				\pgfdeclareimage[width=11cm,height=8cm]{chromosom}{mapa.png}
				\pgfuseimage{chromosom}
			\end{frame}
			\begin{frame}
				\pgfdeclareimage[width=11cm,height=8cm]{chromosom}{macierzOdleglosci.png}
				\pgfuseimage{chromosom}
			\end{frame}
			\begin{frame}{Ocena osobników}
				\pgfdeclareimage[width=10cm,height=8cm]{chromosom}{funkcjaDopasowania.png}
				\pgfuseimage{chromosom}
			\end{frame}
		\begin{frame}{Selekcja}
			Zastosowałem domyślną implementację (domyślnie ustawiana jest klasa BestChromosomesSelector): wybranych zostaje 90 procent najlepsszych osobników, pozostałe 10 procent uzupełnia się, kopiując najlepszych (pod względem funckji dopasowania) osobników aż do wyczerpania miejsca.
		\end{frame}
			\begin{frame}{Przykład działania}
				W ramach eksperymentu stworzyłem sobie następującą sytuację:
				\begin{enumerate}
					\item Należy, wyruszając z punktu 0, odwiedzić wszystkie stoły numerowane od 1 do 5 włącznie i wrócić do punktu 0 (każdy stół musi być odwiedzony tylko raz). 
					\item Odległość między dwoma stołami to wartość bezwzględna z różnicy ich numerów (np. odległość pomiędzy stołem 1., a 3. = |1 - 3| = 2), przy czym odległość pomiędzy stołem numer 5 i punktem 0 wynosi 1.
					\item Przy tak określonym zadaniu nietrudno sprawdzić, że najkrótsza droga to: [1, 2, 3, 4, 5] albo równoważna jej [5, 4, 3, 2, 1] i jej długość wynosi: 6.
					\item Uruchomię mój algorytm 10 razy z takimi samymi ustawieniami, jakie są zaimplementowane w aplikacji Inteligentny kelner (rozmiar populacji - 1000, 2000 ewolucji).
				\end{enumerate}
			\end{frame}
		\begin{frame}{Wyniki doświadczenia}
			\pgfdeclareimage[width=12cm,height=7cm]{chromosom}{eksperymentDD.png}
			\pgfuseimage{chromosom}
		\end{frame}
		\begin{frame}{Wyniki doświadczenia - 100 powtórzeń}
		\pgfdeclareimage[width=11cm,height=8cm]{chromosom}{eksperyment100.png}
		\pgfuseimage{chromosom}
		\end{frame}
		\begin{frame}{Wyniki doświadczenia - 1000 powtórzeń}
			Algorytm wykonywał się 1, 5 godziny.
			\pgfdeclareimage[width=12cm,height=7cm]{chromosom}{eksperyment1000.png}
			\pgfuseimage{chromosom}
		\end{frame}

		

		\section{Drzewa decyzyjne}
		\begin{frame}{Drzewa decyzyjne jako model klasyfikacji}
			Przez drzewo decyzyjne rozumiemy strukturę, która ma zwykłe właściwości drzewa w znaczeniu, jaki temu słowu nadaje się w informatyce, jest więc strukturą złożoną z węzłów, z których wychodzą gałęzie prowadzące do innych węzłów lub liści, oraz z liści, z których nie wychodzą żadne gałęzie. Węzły 			odpowiadają testom przeprowadzanym na wartościach atrybutów przykładów, gałęzie odpowiadają możliwym wynikom tych testów, liście zaś etykietom kategorii.
		\end{frame}

		\begin{frame}{Implementacja}
			\pgfdeclareimage[width=11.18cm,height=3.82cm]{treeClass}{treeClass.png}
			\pgfuseimage{treeClass}
			
		\end{frame}
		
		

		\begin{frame}{Do czego wykorzystujemy drzewa decyzyjne?}
			Zamówienia są generowane w sposób losowy. Przyjęłam założenie, że mamy 5 równolegle pracujących kucharzy, a każdy z nich podejmuje decyzję o wyborze potrawy do przygotowania. Każdy z nich stosuje te same kryteria wyboru, sposób ich rozumowania jest przedstawiony w postaci drzewa. 
		\end{frame}
		
		\begin{frame}{Schemat drzewa decyzyjnego}
			\pgfdeclareimage[width=10.875cm,height=7cm]{treeDiagram}{treeDiagram.png}
			\pgfuseimage{treeDiagram}
		\end{frame}

		\begin{frame}{Zalety drzew decyzyjnych}
			Drzewa decyzyjne: 
				\begin{itemize}
						\item{Mogą reprezentować dowolnie złożone pojęcia pojedyncze lub wielokrotne, jeśli tylko ich definicje  da się wyrazić w zależności od atrybutów}
						\item{Są efektywne obliczeniowo, w najgorszym wypadku proces identyfikacji kategorii wymaga jednokrotnego przetestowania wszystkich atrybutów}
						\item {Forma reprezentacji jest czytelna dla człowieka}
						\item {Łatwo można przejść od reprezentacji drzewiastej do reprezentacji regułowej}
						\end{itemize}
		\end{frame}

		\begin{frame}{Wady drzew decyzyjnych}
			\begin{itemize}
				\item{Testuje się wartość jednego atrybutu na raz, co powoduje niepotrzebny rozrost drzewa dla danych, gdzie poszczególne atrybuty zależą od pozostałych}
				\item{Kosztowna reprezentacja alternatyw pomiędzy atrybutami - znaczny rozrost drzewa (w przeciwieństwi do reprezentacji koniunkcji, która jest zapisywana jako pojedyńcza "ścieżka")}
				\item{Drzewa decyzyjne nie stwarzają łatwej możliwości do ich inkrementacyjnego aktualizowania, algorytmy udoskonalające gotowe już drzewa poprzez zestaw nowych przykładów są bardzo złożone i zazwyczaj wynikiem jest drzewo gorszej jakości niż drzewo budowane od początku z kompletnym zestawem przykładów.}
			\end{itemize}
		\end{frame}
		
		
		\section{Sieci neuronowe}
		
		\begin{frame}
			\textbf{Sztuczna (symulowana) sieć neuronowa} to połączona grupa sztucznych komórek nerwowych, która wykorzystuje model matematyczny w celu przetwarzania informacji. Inspiracją do rozpoczęcia badań nad sztucznymi sieciami neuronowymi było działanie ludzkiego mózgu i próba odtworzenia jego niezwykłej mocy obliczeniowej. Sieci neuronowe składają się ze sztucznych neuronów, które są tutaj odpowiednikami ludzkiej komórki nerwowej. Sztuczne sieci neuronowe mają bardzo szerokie zastosowania od ekonomii począwszy, przez medycynę do techniki.
		
		\end{frame}
		\begin{frame}{Zastosowania sieci neuronowych}
				\begin{itemize}
					\item{Klasyfikacja i rozpoznawanie wzorców (np. pisma),}
					\item{Kojarzenia danych,}
					\item{Synteza mowy,}
					\item{Aproksymacja i prognozowanie.}
				\end{itemize}
		\end{frame}
		\begin{frame}
			Jest wiele różnych rodzajów sieci neuronowych i sposobów ich uczenia. W swoim projekcie zastosowałem wielowarstwową sieć neuronową. Jest to sieć jednokierunkowa (sygnał płynie od warstwy wejściowej do warstwy wyjściowej), która składa się z trzech warstw (warstwa - zbiór neuronów między którymi nie ma żadnych połączeń). Do uczenia sieci użyłem \textbf{algorytmu wstecznej propagacji błędu z członem momentum}. Jest to jeden z najpopularniejszych sposobów uczenia sieci.
		\end{frame}
		\begin{frame}{Algorytm wstecznej propagacji błędu}
			Działanie algorytmu uczenia opiera się na obliczeniu wyjścia sieci, a później propagowaniu błędów wstecz (od warstwy wyjściowej do warstwy wejściowej), ponieważ nie znamy błędów sieci w warstwach ukrytych.\\
			 Podstawą matematyczną optymalizacji wektora wag jest \textbf{metoda największego spadku}, która ma za zadanie minimalizację poniższej funkcji błędu:
			\begin{center}
				$Q(\mathbf{w}(t))=\sum_{i=1}^{N_{L}}(d_{i}^{(L)}-y_{i}^{(L)}(t))^{2}$, gdzie
			\end{center}
			\begin{itemize}
				\item{$\mathbf{w}(t)$ - wektor wag,}
				\item{$d_i$ - wartość $i$-tego indeksu wektora wzorcowego pochodzącego ze zbioru uczącego,}
				\item{$y_i$ - wyjście sieci $i$-tego neuronu warstwy wyjściowej,}
				\item{$N_L$ - liczba neuronów wyjściowych.}
			\end{itemize}
		\end{frame}
		\begin{frame}
			Poprawa wektora wag odbywa się według następującej formuły:
			\begin{center}
				$\mathbf{w}(t+1)=\mathbf{w}(t)-\eta \nabla [Q(\mathbf{w})(t)]$, 
			\end{center}
			gdzie $\eta$ to współczynnik uczenia. Powtarzamy obliczanie:  wyjścia sieci dla obserwacji uczącej, wartość funkcji błędu dla tej obserwacji i poprawiamy wektor wag. Wykonujemy powyższe działania dla każdej obserwacji ze zbioru uczącego. Wykonujemy powyższe procedury aż do momentu, w którym skumulowana wartość funkcji błędu osiągnie satysfakcjonujący dla nas poziom.
		\end{frame}
		\begin{frame}{Wady i zalety algorytmu wstecznej propagacji błędu}
			Zalety:
			\begin{itemize}
				\item jest łatwy do zrozumienia, przez co zdobył zaufanie użytkowników,
				\item ma przewagę nad innymi algorytmami, gdy założenia niezbędne do ich działania są trudne do zrealizowania lub zweryfikowania,
				\item jest metodą powolną, ale w miarę pewną - używając tego algorytmu można prosto rozwiązać prawie każde zadanie, inne algorytmy mogą rozwiązywać zadanie bardzo szybko albo całkowicie zawodzić. 
			\end{itemize}
		\end{frame}
		\begin{frame}
			Wady:
			\begin{itemize}
			\item duża liczba iteracji potrzebna do osiągnięcia minimum,
			\item konieczność wybrania dobrego współczynnika uczenia - zbyt mały spowalnia proces uczenia, a zbyt duży może prowadzić do oscylacji,
			\item wrażliwość na występowanie minimów lokalnych.
			\end{itemize}
		\end{frame}
		\begin{frame}{Momentum}
			W celu przyspieszenia procesu uczenia stosuje się \emph{momentową metodę wstecznej propagacji błędu}. Umożliwia ona bezpieczne zwiększenie efektywnego tempa uczenia oraz stabilność samego procesu. Istotą tej modyfikacji jest wprowadzenie do procesu uaktualniania wagi współczynnika bezwładności, tzw. ,,momentu'', proporcjonalnego do zmiany tej wagi w poprzedniej iteracji. Modyfikacja wag odbywa się wtedy zgodnie z niżej podanym wyrażeniem:
			\begin{center}
				$\mathbf{w}(t+1)=\mathbf{w}(t)-\eta \nabla [Q(\mathbf{w})(t)] -\alpha(\mathbf{w}(t)-\mathbf{w}(t-1)),$
			\end{center}
			gdzie $\alpha$ to wspominany współczynnik momentum. 
		\end{frame}
		\begin{frame}{Implementacja}
				\pgfdeclareimage[width=10cm,height=8cm]{BP}{Backprop1.png}
				\pgfuseimage{BP}
		\end{frame}
		\begin{frame}
			\pgfdeclareimage[width=10cm,height=8cm]{BP}{Backprop2.png}
			\pgfuseimage{BP}
		\end{frame}
		\begin{frame}
			\pgfdeclareimage[width=10cm,height=8cm]{BP}{Backprop3.png}
			\pgfuseimage{BP}
		\end{frame}
		\begin{frame}
			\pgfdeclareimage[width=10cm,height=8cm]{BP}{Backprop4.png}
			\pgfuseimage{BP}
		\end{frame}
		\begin{frame}{Eksperyment}
			Przeprowadziłem eksperyment dla zbioru uczącego i sieci neuronowej o 5 neuronach wejściowych, 13 neuronach ukrytych i 1 neuronie wyjściowym. Algorytm kończył działanie, gdy błąd średniokwadratowy był mniejszy od $0.1$. Otrzymałem następujące wyniki:
		\end{frame}
		\begin{frame}
			\begin{center}		
				\pgfdeclareimage[width=8cm,height=8cm]{BP}{Backprop6.png}
				\pgfuseimage{BP}
			\end{center}
		\end{frame}
		\begin{frame}{Wnioski z eksperymentu}
			Z przeprowadzonych testów można wysnuć następujące wnioski, że wartość funkcji błedu oscyluje cały czas wokół tej samej liczby. Świadczy to o tym, że znaleźliśmy się w minimum lokalnym.
			\begin{itemize}
			 \item Przyczyną tego stanu rzeczy mogą być duże różnice wartości w zbiorze uczącym. Dlatego należy zawsze w tej sytuacji znormalizować dane uczące!
			\item Innym powodem może być za mały zbiór uczący, który nie odzwierciedla za dobrze własności, których wymagamy od uczonej przez nas sieci neurowej. Należy pamiętać, żeby zbiór uczący był zawsze odpowiednio duży!
			\end{itemize}
			Pomimo wszystko błąd sieci na poziomie około $10\%$ jest akceptowalnym wynikiem. W wielu przypadkach taki poziom wystarcza do poprawnego działania sieci.
		\end{frame}
\end{document}